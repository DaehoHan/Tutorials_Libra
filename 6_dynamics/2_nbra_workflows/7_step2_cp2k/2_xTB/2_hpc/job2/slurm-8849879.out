SLURM_JOBID=8849879
SLURM_JOB_NODELIST=cpn-p27-16
SLURM_NNODES=1
SLURMTMPDIR=/scratch/8849879
working directory=/panfs/panfs.cbls.ccr.buffalo.edu/scratch/grp-alexeyak/mohammad/my_repositories/Tutorials_Libra/6_dynamics/2_nbra_workflows/7_step2_cp2k/2_xTB/2_hpc/job2
 The Intel 20.2 compilers are in your path. This is adequate for compiling and
running most codes. Source compilervars.sh for more features including the
debugger. 
 The Intel MPI 2020.2 is in your path. This is adequate for compiling and
running most codes. Run "source
/util/academic/intel/20.2/compilers_and_libraries_2020.2.254/linux/mpi/intel64/bin/mpivars.sh"
for more features including the debugger. 
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > already registered; second conversion method ignored.
  return f(*args, **kwds)
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for boost::python::detail::container_element<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >, unsigned long, boost::python::detail::final_vector_derived_policies<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >, false> > already registered; second conversion method ignored.
  return f(*args, **kwds)
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for std::vector<std::vector<float, std::allocator<float> >, std::allocator<std::vector<float, std::allocator<float> > > > already registered; second conversion method ignored.
  return f(*args, **kwds)
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for boost::python::detail::container_element<std::vector<std::vector<float, std::allocator<float> >, std::allocator<std::vector<float, std::allocator<float> > > >, unsigned long, boost::python::detail::final_vector_derived_policies<std::vector<std::vector<float, std::allocator<float> >, std::allocator<std::vector<float, std::allocator<float> > > >, false> > already registered; second conversion method ignored.
  return f(*args, **kwds)
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for std::vector<std::vector<double, std::allocator<double> >, std::allocator<std::vector<double, std::allocator<double> > > > already registered; second conversion method ignored.
  return f(*args, **kwds)
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for boost::python::detail::container_element<std::vector<std::vector<double, std::allocator<double> >, std::allocator<std::vector<double, std::allocator<double> > > >, unsigned long, boost::python::detail::final_vector_derived_policies<std::vector<std::vector<double, std::allocator<double> >, std::allocator<std::vector<double, std::allocator<double> > > >, false> > already registered; second conversion method ignored.
  return f(*args, **kwds)
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for std::vector<std::vector<std::complex<double>, std::allocator<std::complex<double> > >, std::allocator<std::vector<std::complex<double>, std::allocator<std::complex<double> > > > > already registered; second conversion method ignored.
  return f(*args, **kwds)
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for boost::python::detail::container_element<std::vector<std::vector<std::complex<double>, std::allocator<std::complex<double> > >, std::allocator<std::vector<std::complex<double>, std::allocator<std::complex<double> > > > >, unsigned long, boost::python::detail::final_vector_derived_policies<std::vector<std::vector<std::complex<double>, std::allocator<std::complex<double> > >, std::allocator<std::vector<std::complex<double>, std::allocator<std::complex<double> > > > >, false> > already registered; second conversion method ignored.
  return f(*args, **kwds)
The translational vectors for the current periodic system are:

[[-1 -1  0]
 [-1  0  0]
 [-1  1  0]
 [ 0 -1  0]
 [ 0  1  0]
 [ 1 -1  0]
 [ 1  0  0]
 [ 1  1  0]]
Will compute the S^AO between R(0,0,0) and 9 translational vectors
-----------------------Start-----------------------
-----------------------Step 4-----------------------
**************** Running CP2K ****************
Step 4 Computing the OT method wfn file...
Done with OT wfn. Elapsed time: 2.6806766986846924
Computing the wfn file using diagonalization method...
Done with diagonalization. Elapsed time: 3.177963972091675
Done with step 4 Elapsed time: 5.8890321254730225
Creating shell...
Done with creating shell. Elapsed time: 0.02300286293029785
Reading energies and eigenvectors....
Done with reading energies and eigenvectors. Elapsed time: 0.12279200553894043
Computing atomic orbital overlap matrix...
Computing the AO overlaps between R(-1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(-1,0,0) and R(0,0,0)
Computing the AO overlaps between R(-1,1,0) and R(0,0,0)
Computing the AO overlaps between R(0,-1,0) and R(0,0,0)
Computing the AO overlaps between R(0,1,0) and R(0,0,0)
Computing the AO overlaps between R(1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(1,0,0) and R(0,0,0)
Computing the AO overlaps between R(1,1,0) and R(0,0,0)
Done with computing atomic orbital overlaps. Elapsed time: 0.2707960605621338
Turning the MATRIX to numpy array...
Done with transforming MATRIX 2 numpy array. Elapsed time: 0.02966594696044922
Resorting eigenvectors elements...
Done with resorting eigenvectors elements. Elapsed time: 0.004136085510253906
Computing and saving molecular orbital overlaps...
Done with computing molecular orbital overlaps. Elapsed time: 0.04547882080078125
Done with step 4. Elapsed time: 6.384969234466553
-----------------------Step 5-----------------------
**************** Running CP2K ****************
Step 5 Computing the OT method wfn file...
Done with OT wfn. Elapsed time: 1.6790189743041992
Computing the wfn file using diagonalization method...
Done with diagonalization. Elapsed time: 1.5515666007995605
Done with step 5 Elapsed time: 3.254401206970215
Creating shell...
Done with creating shell. Elapsed time: 0.0244748592376709
Reading energies and eigenvectors....
Done with reading energies and eigenvectors. Elapsed time: 0.12336206436157227
Computing atomic orbital overlap matrix...
Computing the AO overlaps between R(-1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(-1,0,0) and R(0,0,0)
Computing the AO overlaps between R(-1,1,0) and R(0,0,0)
Computing the AO overlaps between R(0,-1,0) and R(0,0,0)
Computing the AO overlaps between R(0,1,0) and R(0,0,0)
Computing the AO overlaps between R(1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(1,0,0) and R(0,0,0)
Computing the AO overlaps between R(1,1,0) and R(0,0,0)
Done with computing atomic orbital overlaps. Elapsed time: 0.2656111717224121
Turning the MATRIX to numpy array...
Done with transforming MATRIX 2 numpy array. Elapsed time: 0.059580326080322266
Resorting eigenvectors elements...
Done with resorting eigenvectors elements. Elapsed time: 0.004293918609619141
Computing and saving molecular orbital overlaps...
Done with computing molecular orbital overlaps. Elapsed time: 0.06551384925842285
Removing unnecessary wfn files...
Done with step 5. Elapsed time: 3.8350017070770264
-----------------------Step 6-----------------------
**************** Running CP2K ****************
Step 6 Computing the OT method wfn file...
Done with OT wfn. Elapsed time: 1.6772193908691406
Computing the wfn file using diagonalization method...
Done with diagonalization. Elapsed time: 1.5668056011199951
Done with step 6 Elapsed time: 3.2809536457061768
Creating shell...
Done with creating shell. Elapsed time: 0.02460455894470215
Reading energies and eigenvectors....
Done with reading energies and eigenvectors. Elapsed time: 0.12266969680786133
Computing atomic orbital overlap matrix...
Computing the AO overlaps between R(-1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(-1,0,0) and R(0,0,0)
Computing the AO overlaps between R(-1,1,0) and R(0,0,0)
Computing the AO overlaps between R(0,-1,0) and R(0,0,0)
Computing the AO overlaps between R(0,1,0) and R(0,0,0)
Computing the AO overlaps between R(1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(1,0,0) and R(0,0,0)
Computing the AO overlaps between R(1,1,0) and R(0,0,0)
Done with computing atomic orbital overlaps. Elapsed time: 0.24941611289978027
Turning the MATRIX to numpy array...
Done with transforming MATRIX 2 numpy array. Elapsed time: 0.060114383697509766
Resorting eigenvectors elements...
Done with resorting eigenvectors elements. Elapsed time: 0.0041506290435791016
Computing and saving molecular orbital overlaps...
Done with computing molecular orbital overlaps. Elapsed time: 0.0474848747253418
Removing unnecessary wfn files...
Done with step 6. Elapsed time: 3.8217077255249023
-----------------------Step 7-----------------------
**************** Running CP2K ****************
Step 7 Computing the OT method wfn file...
Done with OT wfn. Elapsed time: 1.6764864921569824
Computing the wfn file using diagonalization method...
Done with diagonalization. Elapsed time: 1.5567333698272705
Done with step 7 Elapsed time: 3.2576406002044678
Creating shell...
Done with creating shell. Elapsed time: 0.0429844856262207
Reading energies and eigenvectors....
Done with reading energies and eigenvectors. Elapsed time: 0.14956402778625488
Computing atomic orbital overlap matrix...
Computing the AO overlaps between R(-1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(-1,0,0) and R(0,0,0)
Computing the AO overlaps between R(-1,1,0) and R(0,0,0)
Computing the AO overlaps between R(0,-1,0) and R(0,0,0)
Computing the AO overlaps between R(0,1,0) and R(0,0,0)
Computing the AO overlaps between R(1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(1,0,0) and R(0,0,0)
Computing the AO overlaps between R(1,1,0) and R(0,0,0)
Done with computing atomic orbital overlaps. Elapsed time: 0.2533230781555176
Turning the MATRIX to numpy array...
Done with transforming MATRIX 2 numpy array. Elapsed time: 0.060385704040527344
Resorting eigenvectors elements...
Done with resorting eigenvectors elements. Elapsed time: 0.004522562026977539
Computing and saving molecular orbital overlaps...
Done with computing molecular orbital overlaps. Elapsed time: 0.057586669921875
Removing unnecessary wfn files...
Done with step 7. Elapsed time: 3.873140335083008
Done with the job!!!

	Finished computing overlap integral
