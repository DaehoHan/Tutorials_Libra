SLURM_JOBID=8849878
SLURM_JOB_NODELIST=cpn-p27-15
SLURM_NNODES=1
SLURMTMPDIR=/scratch/8849878
working directory=/panfs/panfs.cbls.ccr.buffalo.edu/scratch/grp-alexeyak/mohammad/my_repositories/Tutorials_Libra/6_dynamics/2_nbra_workflows/7_step2_cp2k/2_xTB/2_hpc/job1
 The Intel 20.2 compilers are in your path. This is adequate for compiling and
running most codes. Source compilervars.sh for more features including the
debugger. 
 The Intel MPI 2020.2 is in your path. This is adequate for compiling and
running most codes. Run "source
/util/academic/intel/20.2/compilers_and_libraries_2020.2.254/linux/mpi/intel64/bin/mpivars.sh"
for more features including the debugger. 
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads

	Finished computing overlap integral
Will scale over 12 OpenMP threads
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > already registered; second conversion method ignored.
  return f(*args, **kwds)
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for boost::python::detail::container_element<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >, unsigned long, boost::python::detail::final_vector_derived_policies<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >, false> > already registered; second conversion method ignored.
  return f(*args, **kwds)
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for std::vector<std::vector<float, std::allocator<float> >, std::allocator<std::vector<float, std::allocator<float> > > > already registered; second conversion method ignored.
  return f(*args, **kwds)
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for boost::python::detail::container_element<std::vector<std::vector<float, std::allocator<float> >, std::allocator<std::vector<float, std::allocator<float> > > >, unsigned long, boost::python::detail::final_vector_derived_policies<std::vector<std::vector<float, std::allocator<float> >, std::allocator<std::vector<float, std::allocator<float> > > >, false> > already registered; second conversion method ignored.
  return f(*args, **kwds)
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for std::vector<std::vector<double, std::allocator<double> >, std::allocator<std::vector<double, std::allocator<double> > > > already registered; second conversion method ignored.
  return f(*args, **kwds)
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for boost::python::detail::container_element<std::vector<std::vector<double, std::allocator<double> >, std::allocator<std::vector<double, std::allocator<double> > > >, unsigned long, boost::python::detail::final_vector_derived_policies<std::vector<std::vector<double, std::allocator<double> >, std::allocator<std::vector<double, std::allocator<double> > > >, false> > already registered; second conversion method ignored.
  return f(*args, **kwds)
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for std::vector<std::vector<std::complex<double>, std::allocator<std::complex<double> > >, std::allocator<std::vector<std::complex<double>, std::allocator<std::complex<double> > > > > already registered; second conversion method ignored.
  return f(*args, **kwds)
/panasas/scratch/grp-alexeyak/mohammad/softwares/miniconda3/envs/libra/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for boost::python::detail::container_element<std::vector<std::vector<std::complex<double>, std::allocator<std::complex<double> > >, std::allocator<std::vector<std::complex<double>, std::allocator<std::complex<double> > > > >, unsigned long, boost::python::detail::final_vector_derived_policies<std::vector<std::vector<std::complex<double>, std::allocator<std::complex<double> > >, std::allocator<std::vector<std::complex<double>, std::allocator<std::complex<double> > > > >, false> > already registered; second conversion method ignored.
  return f(*args, **kwds)
The translational vectors for the current periodic system are:

[[-1 -1  0]
 [-1  0  0]
 [-1  1  0]
 [ 0 -1  0]
 [ 0  1  0]
 [ 1 -1  0]
 [ 1  0  0]
 [ 1  1  0]]
Will compute the S^AO between R(0,0,0) and 9 translational vectors
-----------------------Start-----------------------
-----------------------Step 1-----------------------
**************** Running CP2K ****************
Step 1 Computing the OT method wfn file...
Done with OT wfn. Elapsed time: 4.040198087692261
Computing the wfn file using diagonalization method...
Done with diagonalization. Elapsed time: 1.631622314453125
Done with step 1 Elapsed time: 5.709043502807617
Creating shell...
Done with creating shell. Elapsed time: 0.028915882110595703
Reading energies and eigenvectors....
Done with reading energies and eigenvectors. Elapsed time: 0.1391453742980957
Computing atomic orbital overlap matrix...
Computing the AO overlaps between R(-1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(-1,0,0) and R(0,0,0)
Computing the AO overlaps between R(-1,1,0) and R(0,0,0)
Computing the AO overlaps between R(0,-1,0) and R(0,0,0)
Computing the AO overlaps between R(0,1,0) and R(0,0,0)
Computing the AO overlaps between R(1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(1,0,0) and R(0,0,0)
Computing the AO overlaps between R(1,1,0) and R(0,0,0)
Done with computing atomic orbital overlaps. Elapsed time: 0.24866509437561035
Turning the MATRIX to numpy array...
Done with transforming MATRIX 2 numpy array. Elapsed time: 0.0297396183013916
Resorting eigenvectors elements...
Done with resorting eigenvectors elements. Elapsed time: 0.004496335983276367
Computing and saving molecular orbital overlaps...
Done with computing molecular orbital overlaps. Elapsed time: 0.052312374114990234
Done with step 1. Elapsed time: 6.212387561798096
-----------------------Step 2-----------------------
**************** Running CP2K ****************
Step 2 Computing the OT method wfn file...
Done with OT wfn. Elapsed time: 1.7303521633148193
Computing the wfn file using diagonalization method...
Done with diagonalization. Elapsed time: 1.664841890335083
Done with step 2 Elapsed time: 3.440214157104492
Creating shell...
Done with creating shell. Elapsed time: 0.030203580856323242
Reading energies and eigenvectors....
Done with reading energies and eigenvectors. Elapsed time: 0.16567540168762207
Computing atomic orbital overlap matrix...
Computing the AO overlaps between R(-1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(-1,0,0) and R(0,0,0)
Computing the AO overlaps between R(-1,1,0) and R(0,0,0)
Computing the AO overlaps between R(0,-1,0) and R(0,0,0)
Computing the AO overlaps between R(0,1,0) and R(0,0,0)
Computing the AO overlaps between R(1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(1,0,0) and R(0,0,0)
Computing the AO overlaps between R(1,1,0) and R(0,0,0)
Done with computing atomic orbital overlaps. Elapsed time: 0.27623748779296875
Turning the MATRIX to numpy array...
Done with transforming MATRIX 2 numpy array. Elapsed time: 0.05978870391845703
Resorting eigenvectors elements...
Done with resorting eigenvectors elements. Elapsed time: 0.004647016525268555
Computing and saving molecular orbital overlaps...
Done with computing molecular orbital overlaps. Elapsed time: 0.07144761085510254
Removing unnecessary wfn files...
Done with step 2. Elapsed time: 4.135780334472656
-----------------------Step 3-----------------------
**************** Running CP2K ****************
Step 3 Computing the OT method wfn file...
Done with OT wfn. Elapsed time: 1.8167636394500732
Computing the wfn file using diagonalization method...
Done with diagonalization. Elapsed time: 1.5879580974578857
Done with step 3 Elapsed time: 3.430868625640869
Creating shell...
Done with creating shell. Elapsed time: 0.04032564163208008
Reading energies and eigenvectors....
Done with reading energies and eigenvectors. Elapsed time: 0.17051458358764648
Computing atomic orbital overlap matrix...
Computing the AO overlaps between R(-1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(-1,0,0) and R(0,0,0)
Computing the AO overlaps between R(-1,1,0) and R(0,0,0)
Computing the AO overlaps between R(0,-1,0) and R(0,0,0)
Computing the AO overlaps between R(0,1,0) and R(0,0,0)
Computing the AO overlaps between R(1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(1,0,0) and R(0,0,0)
Computing the AO overlaps between R(1,1,0) and R(0,0,0)
Done with computing atomic orbital overlaps. Elapsed time: 0.268110990524292
Turning the MATRIX to numpy array...
Done with transforming MATRIX 2 numpy array. Elapsed time: 0.0595550537109375
Resorting eigenvectors elements...
Done with resorting eigenvectors elements. Elapsed time: 0.004540443420410156
Computing and saving molecular orbital overlaps...
Done with computing molecular orbital overlaps. Elapsed time: 0.05083298683166504
Removing unnecessary wfn files...
Done with step 3. Elapsed time: 4.058003187179565
-----------------------Step 4-----------------------
**************** Running CP2K ****************
Step 4 Computing the OT method wfn file...
Done with OT wfn. Elapsed time: 1.8411712646484375
Computing the wfn file using diagonalization method...
Done with diagonalization. Elapsed time: 1.6779396533966064
Done with step 4 Elapsed time: 3.5593976974487305
Creating shell...
Done with creating shell. Elapsed time: 0.02775263786315918
Reading energies and eigenvectors....
Done with reading energies and eigenvectors. Elapsed time: 0.13082456588745117
Computing atomic orbital overlap matrix...
Computing the AO overlaps between R(-1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(-1,0,0) and R(0,0,0)
Computing the AO overlaps between R(-1,1,0) and R(0,0,0)
Computing the AO overlaps between R(0,-1,0) and R(0,0,0)
Computing the AO overlaps between R(0,1,0) and R(0,0,0)
Computing the AO overlaps between R(1,-1,0) and R(0,0,0)
Computing the AO overlaps between R(1,0,0) and R(0,0,0)
Computing the AO overlaps between R(1,1,0) and R(0,0,0)
Done with computing atomic orbital overlaps. Elapsed time: 0.25091075897216797
Turning the MATRIX to numpy array...
Done with transforming MATRIX 2 numpy array. Elapsed time: 0.055176734924316406
Resorting eigenvectors elements...
Done with resorting eigenvectors elements. Elapsed time: 0.004182577133178711
Computing and saving molecular orbital overlaps...
Done with computing molecular orbital overlaps. Elapsed time: 0.048966407775878906
Removing unnecessary wfn files...
Done with step 4. Elapsed time: 4.118736267089844
Done with the job!!!

	Finished computing overlap integral
